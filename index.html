<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>note stats dashboard</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #0a0a0f;
  --bg-secondary: #12121a;
  --bg-card: #16161f;
  --bg-card-hover: #1c1c28;
  --border: #2a2a3a;
  --border-subtle: #1e1e2e;
  --text-primary: #e8e8f0;
  --text-secondary: #8888a0;
  --text-muted: #555570;
  --accent-cyan: #00d4ff;
  --accent-cyan-dim: #00d4ff33;
  --accent-pink: #ff3d8e;
  --accent-pink-dim: #ff3d8e33;
  --accent-amber: #ffb020;
  --accent-amber-dim: #ffb02033;
  --accent-green: #00e676;
  --accent-green-dim: #00e67633;
  --accent-purple: #a855f7;
  --accent-purple-dim: #a855f733;
  --glow-cyan: 0 0 20px #00d4ff22;
  --glow-pink: 0 0 20px #ff3d8e22;
  --font-mono: 'JetBrains Mono', monospace;
  --font-sans: 'Noto Sans JP', sans-serif;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-sans);
  min-height: 100vh;
  overflow-x: hidden;
}

/* Subtle grid background */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image:
    linear-gradient(var(--border-subtle) 1px, transparent 1px),
    linear-gradient(90deg, var(--border-subtle) 1px, transparent 1px);
  background-size: 60px 60px;
  opacity: 0.3;
  pointer-events: none;
  z-index: 0;
}

.app { position: relative; z-index: 1; }

/* Header */
.header {
  padding: 32px 40px 24px;
  border-bottom: 1px solid var(--border);
  background: linear-gradient(180deg, #0e0e16 0%, var(--bg-primary) 100%);
}

.header-top {
  display: flex;
  align-items: baseline;
  gap: 16px;
  margin-bottom: 8px;
}

.header h1 {
  font-family: var(--font-mono);
  font-size: 24px;
  font-weight: 600;
  color: var(--accent-cyan);
  letter-spacing: -0.5px;
}

.header h1 span {
  color: var(--text-muted);
  font-weight: 300;
}

.header-meta {
  font-family: var(--font-mono);
  font-size: 14px;
  color: var(--text-muted);
}

.header-meta .live {
  color: var(--accent-green);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* KPI Strip */
.kpi-strip {
  display: flex;
  gap: 1px;
  background: var(--border);
  margin: 0;
  border-bottom: 1px solid var(--border);
}

.kpi-item {
  flex: 1;
  background: var(--bg-secondary);
  padding: 20px 24px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.kpi-label {
  font-family: var(--font-mono);
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-muted);
}

.kpi-value {
  font-family: var(--font-mono);
  font-size: 34px;
  font-weight: 700;
  color: var(--text-primary);
  line-height: 1;
}

.kpi-value.cyan { color: var(--accent-cyan); }
.kpi-value.pink { color: var(--accent-pink); }
.kpi-value.amber { color: var(--accent-amber); }
.kpi-value.green { color: var(--accent-green); }
.kpi-value.purple { color: var(--accent-purple); }

.kpi-sub {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text-muted);
}

.kpi-sub .up { color: var(--accent-green); }
.kpi-sub .down { color: var(--accent-pink); }
.kpi-sub .flat { color: var(--text-muted); }

.kpi-sub .arrow {
  font-size: 16px;
  margin-right: 2px;
}

/* Detail KPI sub strip */
.kpi-strip-sub {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.kpi-item-sub {
  flex: 1;
  background: var(--bg-secondary);
  padding: 10px 24px;
  display: flex;
  align-items: center;
  gap: 10px;
  font-family: var(--font-mono);
}

.kpi-sub-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-muted);
}

.kpi-sub-value {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-secondary);
}

.kpi-sub-diff {
  font-size: 12px;
  color: var(--text-muted);
}

.kpi-sub-diff .up { color: var(--accent-green); }
.kpi-sub-diff .down { color: var(--accent-pink); }

/* Main Grid */
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--border);
  border-bottom: 1px solid var(--border);
}

.panel {
  background: var(--bg-primary);
  padding: 24px;
  min-height: 400px;
  display: flex;
  flex-direction: column;
}

.panel-full {
  grid-column: 1 / -1;
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  flex-shrink: 0;
}

.panel-title {
  font-family: var(--font-mono);
  font-size: 14px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-secondary);
}

.panel-title::before {
  content: '‚ñ∏ ';
  color: var(--accent-cyan);
}

.panel-badge {
  font-family: var(--font-mono);
  font-size: 12px;
  padding: 3px 8px;
  border-radius: 3px;
  background: var(--accent-cyan-dim);
  color: var(--accent-cyan);
  border: 1px solid #00d4ff44;
}

/* Charts container */
.chart-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

/* Bar chart (horizontal) */
.bar-chart {
  display: flex;
  flex-direction: column;
  gap: 3px;
  overflow-y: auto;
  max-height: 440px;
  padding-right: 8px;
}

.bar-chart::-webkit-scrollbar { width: 4px; }
.bar-chart::-webkit-scrollbar-track { background: var(--bg-secondary); }
.bar-chart::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.bar-row {
  display: grid;
  grid-template-columns: 1fr 60px;
  align-items: center;
  gap: 12px;
  padding: 4px 0;
  font-size: 12px;
  cursor: default;
  transition: background 0.15s;
  padding: 4px 8px;
  border-radius: 4px;
}

.bar-row:hover {
  background: var(--bg-card);
}

.bar-label-wrap {
  display: flex;
  flex-direction: column;
  gap: 3px;
  min-width: 0;
}

.bar-title {
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bar-track {
  width: 100%;
  height: 6px;
  background: var(--bg-card);
  border-radius: 3px;
  overflow: hidden;
}

.bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
  position: relative;
}

.bar-fill.cyan { background: linear-gradient(90deg, var(--accent-cyan), #00a8cc); }
.bar-fill.pink { background: linear-gradient(90deg, var(--accent-pink), #cc2266); }
.bar-fill.amber { background: linear-gradient(90deg, var(--accent-amber), #cc8800); }

.bar-value {
  font-family: var(--font-mono);
  font-size: 14px;
  font-weight: 600;
  text-align: right;
  color: var(--accent-cyan);
}

/* Canvas inside chart containers (scatter, eta trend) */
.chart-container canvas {
  width: 100% !important;
  height: 100% !important;
}

/* Sparkline canvas: fixed height */
canvas.trend-row-spark {
  width: 100%;
  height: 66px;
  display: block;
}

/* Decay chart */
.decay-legend {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  margin-top: 12px;
}

.decay-legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: var(--text-secondary);
  font-family: var(--font-mono);
}

.decay-legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

/* Summary line chart */
.summary-legend {
  display: flex;
  gap: 20px;
  margin-top: 8px;
}

.summary-legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-secondary);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: opacity 0.2s;
}

.summary-legend-item:hover { opacity: 0.8; }

.summary-legend-line {
  width: 16px;
  height: 3px;
  border-radius: 2px;
}

/* Tooltip */
.tooltip {
  position: fixed;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 14px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text-primary);
  pointer-events: none;
  z-index: 100;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  max-width: 300px;
  display: none;
}

.tooltip-title {
  color: var(--accent-cyan);
  margin-bottom: 4px;
  font-weight: 600;
}

.tooltip-row {
  color: var(--text-secondary);
  line-height: 1.6;
}

/* Footer */
.footer {
  padding: 16px 40px;
  text-align: center;
  font-family: var(--font-mono);
  font-size: 10px;
  color: var(--text-muted);
}

/* Responsive */
@media (max-width: 900px) {
  .grid { grid-template-columns: 1fr; }
  .kpi-strip { flex-wrap: wrap; }
  .kpi-item { min-width: 50%; }
  .header { padding: 20px; }
  .panel { padding: 16px; }
  .commentary-strip { padding: 12px 20px; flex-wrap: wrap; gap: 8px; }
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.panel { animation: fadeIn 0.4s ease-out both; }
.panel:nth-child(2) { animation-delay: 0.1s; }
.panel:nth-child(3) { animation-delay: 0.2s; }
.panel:nth-child(4) { animation-delay: 0.3s; }

/* Commentary strip */
.commentary-strip {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 14px 40px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  font-family: var(--font-mono);
}

.commentary-label {
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
  letter-spacing: 0.5px;
}

.commentary-text {
  font-size: 14px;
  color: var(--text-primary);
  flex: 1;
}

.commentary-copy {
  font-family: var(--font-mono);
  font-size: 12px;
  color: var(--accent-cyan);
  background: none;
  border: 1px solid var(--accent-cyan-dim);
  padding: 4px 14px;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.2s;
}

.commentary-copy:hover {
  background: var(--accent-cyan-dim);
}

/* Trend panel */
.trend-panel {
  min-height: auto;
}

.trend-tabs {
  display: flex;
  gap: 2px;
  margin-bottom: 16px;
}

.trend-tab {
  font-family: var(--font-mono);
  font-size: 13px;
  padding: 6px 18px;
  background: var(--bg-card);
  color: var(--text-muted);
  border: 1px solid var(--border);
  border-radius: 4px 4px 0 0;
  cursor: pointer;
  transition: all 0.15s;
}

.trend-tab:hover { color: var(--text-secondary); }
.trend-tab.active {
  background: var(--bg-primary);
  color: var(--accent-cyan);
  border-bottom-color: var(--bg-primary);
}

.trend-filters {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  font-family: var(--font-mono);
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 12px;
}

.trend-filters label {
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}

.trend-filters select,
.trend-filters input[type="number"] {
  background: var(--bg-card);
  color: var(--text-primary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 6px;
  font-family: var(--font-mono);
  font-size: 12px;
  outline: none;
}

.trend-filters select:focus,
.trend-filters input:focus {
  border-color: var(--accent-cyan);
}

.trend-rows {
  display: flex;
  flex-direction: column;
  gap: 2px;
  overflow-y: auto;
  max-height: 600px;
  padding-right: 4px;
}

.trend-rows::-webkit-scrollbar { width: 4px; }
.trend-rows::-webkit-scrollbar-track { background: var(--bg-secondary); }
.trend-rows::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.trend-row {
  display: grid;
  grid-template-columns: minmax(220px, 1.5fr) 3fr 50px;
  align-items: center;
  gap: 8px;
  padding: 2px 8px;
  border-radius: 3px;
  transition: background 0.15s;
  cursor: default;
}

.trend-row:hover { background: var(--bg-card); }

.trend-row-title {
  font-size: 12px;
  color: var(--text-secondary);
  white-space: normal;
  word-break: break-all;
  line-height: 1.4;
}

.trend-row-spark {
  height: 66px;
  max-height: 66px;
  min-height: 66px;
}

.trend-row-value {
  font-family: var(--font-mono);
  font-size: 13px;
  font-weight: 600;
  text-align: right;
  color: var(--accent-cyan);
}

/* Toggle group (scatter mode switch) */
.toggle-group {
  display: flex;
  gap: 2px;
  font-family: var(--font-mono);
  font-size: 12px;
}

.toggle-btn {
  padding: 3px 10px;
  border: 1px solid var(--border);
  background: var(--bg-card);
  color: var(--text-muted);
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.15s;
}

.toggle-btn.active {
  background: var(--accent-cyan-dim);
  color: var(--accent-cyan);
  border-color: #00d4ff44;
}

/* Category badge */
.cat-badge {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 600;
  margin-right: 4px;
}

/* No data state */
.no-data {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  font-family: var(--font-mono);
  font-size: 13px;
}
</style>
</head>
<body>

<div class="app">
  <!-- Header -->
  <header class="header">
    <div class="header-top">
      <h1>note-stats <span>dashboard</span></h1>
    </div>
    <div class="header-meta">
      <span class="live">‚óè</span> data updated: <span id="lastUpdate">--</span>
      &nbsp;|&nbsp; articles: <span id="articleCount">--</span>
      &nbsp;|&nbsp; tracking since: <span id="trackingSince">--</span>
    </div>
  </header>

  <!-- KPI Strip -->
  <div class="kpi-strip">
    <div class="kpi-item">
      <div class="kpi-label">„É™„Éº„ÉÅÂäõ (TotalPV/articles)</div>
      <div class="kpi-value cyan" id="kpiReach">--</div>
      <div class="kpi-sub" id="kpiReachSub"></div>
    </div>
    <div class="kpi-item">
      <div class="kpi-label">„Ç¢„ÇØ„Ç∑„Éß„É≥Âäõ (TotalLikes/articles)</div>
      <div class="kpi-value pink" id="kpiAction">--</div>
      <div class="kpi-sub" id="kpiActionSub"></div>
    </div>
    <div class="kpi-item">
      <div class="kpi-label">„Çπ„Ç≠Áéá Œ∑ (TotalLikes/TotalPV)</div>
      <div class="kpi-value amber" id="kpiEta">--</div>
      <div class="kpi-sub" id="kpiEtaSub"></div>
    </div>
    <div class="kpi-item">
      <div class="kpi-label">Followers</div>
      <div class="kpi-value green" id="kpiFollowers">--</div>
      <div class="kpi-sub" id="kpiFollowersSub"></div>
    </div>
    <div class="kpi-item">
      <div class="kpi-label">Articles</div>
      <div class="kpi-value purple" id="kpiArticles">--</div>
      <div class="kpi-sub" id="kpiArticlesSub"></div>
    </div>
  </div>

  <!-- Detail KPI (Total PV / Likes / Comments) -->
  <div class="kpi-strip kpi-strip-sub">
    <div class="kpi-item-sub">
      <span class="kpi-sub-label">Total PV</span>
      <span class="kpi-sub-value" id="kpiPV">--</span>
      <span class="kpi-sub-diff" id="kpiPVsub"></span>
    </div>
    <div class="kpi-item-sub">
      <span class="kpi-sub-label">Total Likes</span>
      <span class="kpi-sub-value" id="kpiLikes">--</span>
      <span class="kpi-sub-diff" id="kpiLikesSub"></span>
    </div>
    <div class="kpi-item-sub">
      <span class="kpi-sub-label">Total Comments</span>
      <span class="kpi-sub-value" id="kpiComments">--</span>
      <span class="kpi-sub-diff" id="kpiCommentsSub"></span>
    </div>
  </div>

  <!-- Áä∂ÊÖã„É°„É¢ÔºàËá™ÂãïÁîüÊàêÔºâ -->
  <div class="commentary-strip" id="commentaryStrip" style="display:none;">
    <div class="commentary-label">üìù ‰ªäÊó•„ÅÆÁä∂ÊÖã„É°„É¢ÔºàËá™ÂãïÁîüÊàêÔºâ</div>
    <div class="commentary-text" id="commentaryText"></div>
    <button class="commentary-copy" id="commentaryCopy" onclick="copyCommentary()">Copy</button>
  </div>

  <!-- Charts Grid -->
  <div class="grid">
    <!-- 1. Like Rate Ranking -->
    <div class="panel">
      <div class="panel-header">
        <div class="panel-title">„Çπ„Ç≠Áéá„É©„É≥„Ç≠„É≥„Ç∞</div>
        <div class="toggle-group" id="rankingToggle">
          <div class="toggle-btn" data-top="5">TOP 5</div>
          <div class="toggle-btn" data-top="10">TOP 10</div>
          <div class="toggle-btn active" data-top="20">TOP 20</div>
        </div>
      </div>
      <div class="chart-container">
        <div class="bar-chart" id="rankingChart">
          <div class="no-data">CSV„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
        </div>
      </div>
      <div class="decay-legend" id="rankingLegend"></div>
    </div>

    <!-- 2. PV vs Likes Scatter -->
    <div class="panel">
      <div class="panel-header">
        <div class="panel-title">PV √ó „Çπ„Ç≠ Êï£Â∏ÉÂõ≥</div>
        <div class="toggle-group" id="scatterToggle">
          <div class="toggle-btn active" data-mode="eta">Œ∑Ëâ≤ÂàÜ„Åë</div>
          <div class="toggle-btn" data-mode="category">„Ç´„ÉÜ„Ç¥„É™Ëâ≤ÂàÜ„Åë</div>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="scatterCanvas"></canvas>
      </div>
      <div class="decay-legend" id="scatterLegend"></div>
    </div>

    <!-- 3. Category Œ∑ Comparison (full width) -->
    <div class="panel panel-full" style="min-height:auto; max-height:600px;">
      <div class="panel-header">
        <div class="panel-title">„Ç´„ÉÜ„Ç¥„É™Âà• „Çπ„Ç≠ÁéáÊØîËºÉ</div>
        <div class="panel-badge" id="catBadge">--</div>
      </div>
      <div class="chart-container" style="min-height:280px; max-height:420px;">
        <canvas id="categoryCanvas"></canvas>
      </div>
      <div class="decay-legend" id="categoryLegend"></div>
    </div>

    <!-- 4. Recent Articles Œ∑ Trend (full width) -->
    <div class="panel panel-full" style="min-height:auto; max-height:600px;">
      <div class="panel-header">
        <div class="panel-title">Áõ¥Ëøë2ÈÄ±Èñì „Çπ„Ç≠ÁéáÊé®Áßª</div>
        <div class="panel-badge" id="etaTrendBadge">--</div>
      </div>
      <div class="chart-container" style="max-height:420px;">
        <canvas id="etaTrendCanvas"></canvas>
      </div>
      <div class="decay-legend" id="etaTrendLegend"></div>
    </div>

    <!-- 4. Article Trend (sparkline rows with tabs) -->
    <div class="panel panel-full trend-panel">
      <div class="panel-header">
        <div class="panel-title">Ë®ò‰∫ãÂà• Êó•Ê¨°Êé®Áßª</div>
        <div class="panel-badge" id="trendBadge">--</div>
      </div>
      <div class="trend-tabs">
        <div class="trend-tab active" data-metric="pv_delta">PV</div>
        <div class="trend-tab" data-metric="like_delta">„Çπ„Ç≠</div>
      </div>
      <div class="trend-filters">
        <label>ÊäïÁ®øÊó•: Áõ¥Ëøë
          <select id="trendDayFilter">
            <option value="7">7Êó•</option>
            <option value="14" selected>14Êó•</option>
            <option value="30">30Êó•</option>
            <option value="0">„Åô„Åπ„Å¶</option>
          </select>
        </label>
        <label>Â¢óÂàÜ ‚â•
          <input id="trendMinDelta" type="number" value="0" min="0" style="width:60px">
        </label>
        <label>„Ç´„ÉÜ„Ç¥„É™:
          <select id="trendCatFilter">
            <option value="">„Åô„Åπ„Å¶</option>
            <option value="A">A Ë®≠Ë®àÊÄùÊÉ≥</option>
            <option value="B">B Ë©¶Ë°åÈåØË™§</option>
            <option value="C">C „Éè„Ç¶„ÉÑ„Éº</option>
            <option value="D">D ÊåØ„ÇäËøî„Çä</option>
            <option value="E">E „Ç≠„É£„É©Á≥ª</option>
            <option value="AB">A+B ‰∏ÄÊ¨°ÊÉÖÂ†±</option>
          </select>
        </label>
      </div>
      <div class="trend-rows" id="trendRows">
        <div class="no-data">„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
      </div>
    </div>
  </div>

  <footer class="footer">
    note-stats-dashboard v0.1 ‚Äî data stays in your browser
  </footer>
</div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip">
  <div class="tooltip-title" id="tooltipTitle"></div>
  <div class="tooltip-row" id="tooltipBody"></div>
</div>

<script>
// ===== State =====
let articlesData = [];
let dailySummary = [];
let latestSnapshot = [];
let summaryData = []; // from daily_summary.csv
let categoryMap = {}; // key ‚Üí category

// ===== Category Meta =====
const CATEGORY_META = {
  A: { name: 'Ë®≠Ë®àÊÄùÊÉ≥', color: '#00d4ff', primary: true },
  B: { name: 'Ë©¶Ë°åÈåØË™§', color: '#ff3d8e', primary: true },
  C: { name: '„Éè„Ç¶„ÉÑ„Éº', color: '#ffb020', primary: false },
  D: { name: 'ÊåØ„ÇäËøî„Çä', color: '#00e676', primary: false },
  E: { name: '„Ç≠„É£„É©Á≥ª', color: '#a855f7', primary: false },
  F: { name: 'ÂàùÊúüÊó•Ë®ò', color: '#555570', primary: false },
  G: { name: 'ÁâπÂà•Êû†',  color: '#888888', primary: false },
};

function getCategoryColor(cat) {
  return (CATEGORY_META[cat] || {}).color || '#555570';
}

function getCategoryName(cat) {
  return (CATEGORY_META[cat] || {}).name || '‰∏çÊòé';
}

// ===== CSV Parser =====
function parseCSV(text) {
  const lines = text.trim().replace(/\r/g, '').split('\n');
  if (lines.length < 2) return [];
  const headers = lines[0].split(',');
  return lines.slice(1).map(line => {
    const vals = [];
    let current = '';
    let inQuotes = false;
    for (const ch of line) {
      if (ch === '"') { inQuotes = !inQuotes; }
      else if (ch === ',' && !inQuotes) { vals.push(current); current = ''; }
      else { current += ch; }
    }
    vals.push(current);
    const obj = {};
    headers.forEach((h, i) => obj[h.trim()] = (vals[i] || '').trim());
    return obj;
  });
}

// ===== Data Processing =====
function processData(rows) {
  articlesData = rows.map(r => ({
    date: r.date,
    note_id: r.note_id,
    key: r.key,
    title: r.title || '',
    published_at: r.published_at || '',
    age_days: parseInt(r.age_days) || 0,
    read_count: parseInt(r.read_count) || 0,
    like_count: parseInt(r.like_count) || 0,
    comment_count: parseInt(r.comment_count) || 0,
    category: categoryMap[r.key] || '?',
  }));

  // Get unique dates sorted
  const dates = [...new Set(articlesData.map(a => a.date))].sort();

  // Latest snapshot (most recent date)
  const latestDate = dates[dates.length - 1];
  latestSnapshot = articlesData.filter(a => a.date === latestDate);

  // Daily summary from each date
  dailySummary = dates.map(d => {
    const dayArticles = articlesData.filter(a => a.date === d);
    const totalPV = dayArticles.reduce((s, a) => s + a.read_count, 0);
    const totalLikes = dayArticles.reduce((s, a) => s + a.like_count, 0);
    const totalComments = dayArticles.reduce((s, a) => s + a.comment_count, 0);
    return { date: d, totalPV, totalLikes, totalComments, articleCount: dayArticles.length };
  });

  updateKPI();
  updateCommentary();
  renderRanking();
  renderScatter();
  renderCategoryChart();
  renderEtaTrend();
  renderTrendCharts();
  updateHeader(dates);
}

// ===== KPI =====
function updateKPI() {
  // Use summaryData if available, otherwise fall back to articles-derived summary
  const src = summaryData.length > 0 ? summaryData : dailySummary;
  const latest = src[src.length - 1];
  const prev = src.length > 1 ? src[src.length - 2] : null;

  if (!latest) return;

  const articleCount = latest.articleCount || latestSnapshot.length;
  const totalPV = latest.totalPV;
  const totalLikes = latest.totalLikes;
  const totalComments = latest.totalComments;
  const followers = latest.followerCount || 0;

  // 3KPI (KITAcore style)
  const reach = articleCount > 0 ? (totalPV / articleCount) : 0;
  const action = articleCount > 0 ? (totalLikes / articleCount) : 0;
  const eta = totalPV > 0 ? (totalLikes / totalPV * 100) : 0;

  document.getElementById('kpiReach').textContent = reach.toFixed(1);
  document.getElementById('kpiAction').textContent = action.toFixed(1);
  document.getElementById('kpiEta').textContent = eta.toFixed(1) + '%';
  document.getElementById('kpiFollowers').textContent = followers.toLocaleString();
  document.getElementById('kpiArticles').textContent = articleCount;

  // Detail row
  document.getElementById('kpiPV').textContent = totalPV.toLocaleString();
  document.getElementById('kpiLikes').textContent = totalLikes.toLocaleString();
  document.getElementById('kpiComments').textContent = totalComments.toLocaleString();

  if (prev) {
    const prevArticleCount = prev.articleCount || articleCount;
    const prevPV = prev.totalPV;
    const prevLikes = prev.totalLikes;
    const prevComments = prev.totalComments;
    const prevFollowers = prev.followerCount || 0;

    const prevReach = prevArticleCount > 0 ? (prevPV / prevArticleCount) : 0;
    const prevAction = prevArticleCount > 0 ? (prevLikes / prevArticleCount) : 0;
    const prevEta = prevPV > 0 ? (prevLikes / prevPV * 100) : 0;

    document.getElementById('kpiReachSub').innerHTML = arrowLabel(reach - prevReach, '/article');
    document.getElementById('kpiActionSub').innerHTML = arrowLabel(action - prevAction, '/article');
    document.getElementById('kpiEtaSub').innerHTML = arrowLabel(eta - prevEta, 'pts', true);
    document.getElementById('kpiFollowersSub').innerHTML = arrowLabel(followers - prevFollowers, '');
    document.getElementById('kpiArticlesSub').innerHTML = arrowLabel(articleCount - prevArticleCount, ' new');

    // Detail row diffs
    document.getElementById('kpiPVsub').innerHTML = diffBadge(totalPV - prevPV);
    document.getElementById('kpiLikesSub').innerHTML = diffBadge(totalLikes - prevLikes);
    document.getElementById('kpiCommentsSub').innerHTML = diffBadge(totalComments - prevComments);
  }
}

function arrowLabel(diff, unit, isFloat) {
  let arrow, cls;
  if (diff > 0.001) { arrow = '‚Üë'; cls = 'up'; }
  else if (diff < -0.001) { arrow = '‚Üì'; cls = 'down'; }
  else { arrow = '‚Üí'; cls = 'flat'; }
  const val = isFloat ? Math.abs(diff).toFixed(2) : Math.abs(Math.round(diff));
  return `<span class="${cls}"><span class="arrow">${arrow}</span>${val}${unit}</span>`;
}

function diffBadge(diff) {
  const sign = diff >= 0 ? '+' : '';
  const cls = diff >= 0 ? 'up' : 'down';
  return `<span class="${cls}">${sign}${diff}</span>`;
}

// ===== Commentary Auto-generation =====
function updateCommentary() {
  const src = summaryData.length > 0 ? summaryData : dailySummary;
  if (src.length < 2) {
    document.getElementById('commentaryStrip').style.display = 'none';
    return;
  }

  const latest = src[src.length - 1];
  const prev = src[src.length - 2];

  const articleCount = latest.articleCount || latestSnapshot.length;
  const prevArticleCount = prev.articleCount || articleCount;

  const reach = articleCount > 0 ? (latest.totalPV / articleCount) : 0;
  const action = articleCount > 0 ? (latest.totalLikes / articleCount) : 0;
  const eta = latest.totalPV > 0 ? (latest.totalLikes / latest.totalPV * 100) : 0;

  const prevReach = prevArticleCount > 0 ? (prev.totalPV / prevArticleCount) : 0;
  const prevAction = prevArticleCount > 0 ? (prev.totalLikes / prevArticleCount) : 0;
  const prevEta = prev.totalPV > 0 ? (prev.totalLikes / prev.totalPV * 100) : 0;

  const dir = (diff) => diff > 0.001 ? '‚Üë' : (diff < -0.001 ? '‚Üì' : '‚Üí');

  const rDir = dir(reach - prevReach);
  const aDir = dir(action - prevAction);
  const eDir = dir(eta - prevEta);
  const key = rDir + aDir + eDir;

  const templates = {
    '‚Üë‚Üë‚Üë': 'ÂÖ®ÊåáÊ®ô‰∏äÊòá„ÄÇÂ•ΩË™øÊó•„ÄÇ',
    '‚Üë‚Üë‚Üí': '„É™„Éº„ÉÅ„Éª„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÖ±„Å´‰∏äÊòá„ÄÇ„Çπ„Ç≠Áéá„ÅØÂÆâÂÆö„ÄÇ',
    '‚Üë‚Üë‚Üì': 'Èú≤Âá∫„ÇÇ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇÇÂ¢óÂä†„ÄÇ„Åü„Å†„Åó„Çπ„Ç≠Áéá„ÅØ‰Ωé‰∏ã„ÄÅÊñ∞Ë¶èÊµÅÂÖ•„ÅåÂ§ö„ÅÑÂèØËÉΩÊÄß„ÄÇ',
    '‚Üë‚Üí‚Üë': '„É™„Éº„ÉÅÊã°Â§ßÔºã„Çπ„Ç≠Áéá‰∏äÊòá„ÄÇË™≠ËÄÖ„ÅÆË≥™„ÅåËâØ„ÅÑÊµÅÂÖ•„ÄÇ',
    '‚Üë‚Üí‚Üí': '„É™„Éº„ÉÅÂæÆÂ¢ó„ÄÇÂÖ®‰ΩìÁöÑ„Å´„ÅØÂÆâÂÆöÊé®Áßª„ÄÇ',
    '‚Üë‚Üí‚Üì': '„É™„Éº„ÉÅ„ÅØ‰º∏„Å≥„Åü„Åå„Çπ„Ç≠Áéá‰Ωé‰∏ã„ÄÇ„Çø„Ç§„Éà„É´Âãù„Å°„ÅÆÂèØËÉΩÊÄß„ÄÇ',
    '‚Üë‚Üì‚Üë': 'Èú≤Âá∫„ÅØÂ¢ó„Åà„Åü„Åå„Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏õ„ÄÇ„Çπ„Ç≠Áéá„ÅØÊîπÂñÑ„ÄÅÂõ∫ÂÆöÂ±§„ÅåÂèçÂøú„Åã„ÄÇ',
    '‚Üë‚Üì‚Üí': 'Èú≤Âá∫Â¢ó„ÄÅ„Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏õ„ÄÇÊñ∞Ë¶è„ÅÆÂèçÂøú„ÅåËñÑ„ÅÑÂèØËÉΩÊÄß„ÄÇ',
    '‚Üë‚Üì‚Üì': 'Èú≤Âá∫„ÅØÂ¢ó„Åà„Åü„ÅåÂà∫„Åï„Å£„Å¶„Å™„ÅÑ„ÄÇ„Çø„Ç§„Éà„É´Âãù„Å°„ÅÆÂèØËÉΩÊÄß„ÄÇ',
    '‚Üí‚Üë‚Üë': '„É™„Éº„ÉÅÊ®™„Å∞„ÅÑ„Åß„Ç¢„ÇØ„Ç∑„Éß„É≥„Éª„Çπ„Ç≠Áéá‰∏äÊòá„ÄÇÂÜÖÂÆπ„ÅÆË≥™„ÅåÈ´ò„ÅÑ„ÄÇ',
    '‚Üí‚Üë‚Üí': '„Ç¢„ÇØ„Ç∑„Éß„É≥ÂæÆÂ¢ó„ÄÇÂÆâÂÆö„Åó„ÅüÈÅãÂñ∂Êó•„ÄÇ',
    '‚Üí‚Üë‚Üì': '„Ç¢„ÇØ„Ç∑„Éß„É≥Â¢ó„Å†„Åå„Çπ„Ç≠Áéá‰Ωé‰∏ã„ÄÇPVÂ¢ó„Åå„Ç¢„ÇØ„Ç∑„Éß„É≥Â¢ó„Çí‰∏äÂõû„Å£„Å¶„ÅÑ„Çã„ÄÇ',
    '‚Üí‚Üí‚Üë': '„Çπ„Ç≠Áéá„Å†„ÅëÂæÆÂ¢ó„ÄÇË™≠ËÄÖ„ÅÆË≥™„Åå„Åò„Çè„ÇäÂêë‰∏ä„ÄÇ',
    '‚Üí‚Üí‚Üí': 'ÂÆâÂÆöÊé®Áßª„ÄÇÁèæÁä∂Á∂≠ÊåÅ„ÄÇ',
    '‚Üí‚Üí‚Üì': '„Çπ„Ç≠Áéá„Å†„ÅëÂæÆÊ∏õ„ÄÇÂ§ß„Åç„Å™Â§âÂåñ„ÅØ„Å™„Åó„ÄÇ',
    '‚Üí‚Üì‚Üë': '„Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏õ„Å†„Åå„Çπ„Ç≠Áéá„ÅØ‰∏äÊòá„ÄÇPVÊ∏õ„Åß„Çπ„Ç≠Áéá„ÅåÁõ∏ÂØæÁöÑ„Å´‰∏äÊòá„Åã„ÄÇ',
    '‚Üí‚Üì‚Üí': '„Ç¢„ÇØ„Ç∑„Éß„É≥ÂæÆÊ∏õ„ÄÇÁµåÈÅéË¶≥ÂØü„ÄÇ',
    '‚Üí‚Üì‚Üì': '„Ç¢„ÇØ„Ç∑„Éß„É≥„Éª„Çπ„Ç≠ÁéáÂÖ±„Å´‰Ωé‰∏ã„ÄÇ„ÉÜ„Éº„Éû„ÅãÊäïÁ®ø„Çø„Ç§„Éü„É≥„Ç∞„ÇíÁ¢∫Ë™ç„ÄÇ',
    '‚Üì‚Üë‚Üë': '„É™„Éº„ÉÅÊ∏õ„Åß„ÇÇ„Ç¢„ÇØ„Ç∑„Éß„É≥„Éª„Çπ„Ç≠Áéá„ÅØ‰∏äÊòá„ÄÇÂõ∫ÂÆöË™≠ËÄÖ„ÅÆÂèçÂøú„ÅåÊøÉ„ÅÑÊó•„ÄÇ',
    '‚Üì‚Üë‚Üí': '„É™„Éº„ÉÅÊ∏õ„Å†„Åå„Ç¢„ÇØ„Ç∑„Éß„É≥Â¢ó„ÄÇÂ∞ëÊï∞„Å†„ÅåÂà∫„Åï„Å£„Å¶„ÅÑ„Çã„ÄÇ',
    '‚Üì‚Üë‚Üì': '„É™„Éº„ÉÅÊ∏õ„ÄÅ„Ç¢„ÇØ„Ç∑„Éß„É≥Â¢ó„ÄÅ„Çπ„Ç≠Áéá‰Ωé‰∏ã„ÄÇÂ§âÂãïÂ§ß„Åç„ÇÅ„ÄÅÁøåÊó•„ÇÇË¶≥ÂØü„ÄÇ',
    '‚Üì‚Üí‚Üë': 'ÈñëÊï£Êó•„Å†„ÅåË≥™„ÅØÈ´ò„ÅÑ„ÄÇÂõ∫ÂÆöË™≠ËÄÖ„ÅåÂèçÂøú„ÄÇ',
    '‚Üì‚Üí‚Üí': '„É™„Éº„ÉÅÂæÆÊ∏õ„ÄÇÂ§ß„Åç„Å™Â§âÂåñ„Å™„Åó„ÄÇ',
    '‚Üì‚Üí‚Üì': '„É™„Éº„ÉÅ„Éª„Çπ„Ç≠ÁéáÂÖ±„Å´ÂæÆÊ∏õ„ÄÇÁ∑©„ÇÑ„Åã„Å™‰∏ãÈôçÂÇæÂêë„ÄÇ',
    '‚Üì‚Üì‚Üë': '„É™„Éº„ÉÅ„Éª„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÖ±„Å´Ê∏õÂ∞ë„Å†„Åå„Çπ„Ç≠Áéá„ÅØ‰∏äÊòá„ÄÇPVÊ∏õ„Å´„Çà„ÇãÁõ∏ÂØæÂäπÊûú„ÅÆÂèØËÉΩÊÄß„ÄÇ',
    '‚Üì‚Üì‚Üí': '„É™„Éº„ÉÅ„Éª„Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏õ„ÄÇÊäïÁ®ø„ÅÆ„Å™„ÅÑÊó• or „ÉÜ„Éº„Éû„ÅåÂêà„Çè„Å™„Åã„Å£„ÅüÂèØËÉΩÊÄß„ÄÇ',
    '‚Üì‚Üì‚Üì': 'ÂÖ®ÊåáÊ®ô‰∏ãÈôç„ÄÇ‰∏ÄÊôÇÁöÑ„Å™ËêΩ„Å°Ëæº„Åø„Åã„ÄÅ„ÉÜ„Éº„Éû„Éª„Çø„Ç§„Éü„É≥„Ç∞„ÅÆË¶ãÁõ¥„Åó„Çí„ÄÇ',
  };

  const comment = templates[key] || 'Âà§ÂÆö‰∏çËÉΩ„ÄÇ„Éá„Éº„Çø„ÇíÁ¢∫Ë™ç„ÄÇ';
  const dateStr = latest.date || '';
  const displayComment = `${dateStr} | „É™„Éº„ÉÅ${rDir} „Ç¢„ÇØ„Ç∑„Éß„É≥${aDir} „Çπ„Ç≠Áéá${eDir} | ${comment}`;
  const copyComment = `„É™„Éº„ÉÅ${rDir} „Ç¢„ÇØ„Ç∑„Éß„É≥${aDir} „Çπ„Ç≠Áéá${eDir} | ${comment}`;

  document.getElementById('commentaryText').textContent = displayComment;
  document.getElementById('commentaryText').dataset.copyText = copyComment;
  document.getElementById('commentaryStrip').style.display = 'flex';
}

function copyCommentary() {
  const text = document.getElementById('commentaryText').dataset.copyText;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('commentaryCopy');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
}

function updateHeader(dates) {
  document.getElementById('lastUpdate').textContent = dates[dates.length - 1];
  document.getElementById('articleCount').textContent = latestSnapshot.length;
  document.getElementById('trackingSince').textContent = dates[0];
}

// ===== 1. Ranking =====
let rankingTopN = 20;

function renderRanking() {
  const container = document.getElementById('rankingChart');
  const sorted = [...latestSnapshot]
    .map(a => ({ ...a, eta: a.read_count > 0 ? (a.like_count / a.read_count * 100) : 0 }))
    .sort((a, b) => b.eta - a.eta);

  const top = sorted.slice(0, rankingTopN);
  const maxEta = Math.max(...top.map(a => a.eta), 1);

  container.innerHTML = top.map((a, i) => {
    const pct = (a.eta / maxEta * 100).toFixed(1);
    const cat = a.category || '?';
    const catColor = getCategoryColor(cat);
    const shortTitle = a.title.replace(/^„Äê.*?„Äë/, '').replace(/\|.*$/, '').trim();
    const catInfo = cat !== '?' ? ` / „Ç´„ÉÜ„Ç¥„É™: ${cat}Ôºà${getCategoryName(cat)}Ôºâ` : '';
    return `
      <div class="bar-row" onmouseenter="showTooltip(event, '${escHtml(a.title)}', 'PV: ${a.read_count} / „Çπ„Ç≠: ${a.like_count} / Œ∑: ${a.eta.toFixed(1)}%${catInfo}')" onmouseleave="hideTooltip()">
        <div class="bar-label-wrap">
          <div class="bar-title"><span class="cat-badge" style="color:${catColor}">[${cat}]</span>${shortTitle || a.key}</div>
          <div class="bar-track"><div class="bar-fill" style="width:${pct}%; background: linear-gradient(90deg, ${catColor}, ${catColor}88);"></div></div>
        </div>
        <div class="bar-value" style="color:${catColor}">${a.eta.toFixed(1)}%</div>
      </div>`;
  }).join('');

  document.getElementById('rankingLegend').innerHTML = Object.entries(CATEGORY_META).map(([k, v]) =>
    `<div class="decay-legend-item"><div class="decay-legend-dot" style="background:${v.color}"></div>${k} ${v.name}</div>`
  ).join('');
}

// ===== 2. Scatter =====
let scatterMode = 'eta'; // 'eta' or 'category'

function renderScatter() {
  const canvas = document.getElementById('scatterCanvas');
  const ctx = canvas.getContext('2d');
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  ctx.clearRect(0, 0, W, H);

  if (latestSnapshot.length === 0) return;

  const pad = { top: 20, right: 20, bottom: 40, left: 50 };
  const cw = W - pad.left - pad.right;
  const ch = H - pad.top - pad.bottom;

  const maxPV = Math.max(...latestSnapshot.map(a => a.read_count), 1);
  const maxLike = Math.max(...latestSnapshot.map(a => a.like_count), 1);

  // Grid lines
  ctx.strokeStyle = '#1e1e2e';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (ch / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    const x = pad.left + (cw / 4) * i;
    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, H - pad.bottom); ctx.stroke();
  }

  // Average eta line (diagonal)
  const avgEta = latestSnapshot.reduce((s, a) => s + a.like_count, 0) /
                 Math.max(latestSnapshot.reduce((s, a) => s + a.read_count, 0), 1);
  ctx.strokeStyle = '#ffb02044';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(pad.left, pad.top + ch);
  const diagX = pad.left + cw;
  const diagY = pad.top + ch - (maxPV * avgEta / maxLike) * ch;
  ctx.lineTo(diagX, Math.max(diagY, pad.top));
  ctx.stroke();
  ctx.setLineDash([]);

  // Avg eta label
  ctx.fillStyle = '#ffb02088';
  ctx.font = '12px JetBrains Mono';
  ctx.fillText(`avg Œ∑=${(avgEta * 100).toFixed(1)}%`, diagX - 80, Math.max(diagY, pad.top) - 4);

  // Points
  const points = latestSnapshot.map(a => {
    const x = pad.left + (a.read_count / maxPV) * cw;
    const y = pad.top + ch - (a.like_count / maxLike) * ch;
    const eta = a.read_count > 0 ? a.like_count / a.read_count : 0;
    return { x, y, eta, ...a };
  });

  points.forEach(p => {
    let color, radius;
    if (scatterMode === 'category') {
      const cat = p.category || '?';
      color = getCategoryColor(cat);
      const meta = CATEGORY_META[cat];
      radius = (meta && meta.primary) ? 7 : (cat === 'F' || cat === 'G') ? 3 : 5;
    } else {
      const isHigh = p.eta > avgEta * 1.5;
      const isLow = p.eta < avgEta * 0.5 && p.read_count > maxPV * 0.2;
      color = '#00d4ff';
      radius = 4;
      if (isHigh) { color = '#00e676'; radius = 6; }
      if (isLow) { color = '#ff3d8e'; radius = 6; }
    }

    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
    ctx.fillStyle = color + '88';
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    if (scatterMode === 'eta') {
      const isHigh = p.eta > avgEta * 1.5;
      const isLow = p.eta < avgEta * 0.5 && p.read_count > maxPV * 0.2;
      if (isHigh || isLow) {
        ctx.fillStyle = isHigh ? '#00e676' : '#ff3d8e';
        ctx.font = '11px JetBrains Mono';
        const label = p.title.replace(/^„Äê.*?„Äë/, '').replace(/\|.*$/, '').substring(0, 15);
        ctx.fillText(label, p.x + 8, p.y - 4);
      }
    }
  });

  // Axes labels
  ctx.fillStyle = '#555570';
  ctx.font = '12px JetBrains Mono';
  ctx.textAlign = 'center';
  ctx.fillText('PV ‚Üí', W / 2, H - 8);
  ctx.save();
  ctx.translate(12, H / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('„Çπ„Ç≠ ‚Üí', 0, 0);
  ctx.restore();
  ctx.textAlign = 'start';

  // Axis numbers
  ctx.fillStyle = '#555570';
  ctx.font = '11px JetBrains Mono';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 4; i++) {
    const val = Math.round(maxLike / 4 * (4 - i));
    ctx.fillText(val, pad.left - 6, pad.top + (ch / 4) * i + 4);
  }
  ctx.textAlign = 'center';
  for (let i = 0; i <= 4; i++) {
    const val = Math.round(maxPV / 4 * i);
    ctx.fillText(val, pad.left + (cw / 4) * i, H - pad.bottom + 16);
  }

  // Legend
  const legend = document.getElementById('scatterLegend');
  if (scatterMode === 'category') {
    legend.innerHTML = Object.entries(CATEGORY_META).map(([k, v]) =>
      `<div class="decay-legend-item"><div class="decay-legend-dot" style="background:${v.color}"></div>${k} ${v.name}</div>`
    ).join('');
  } else {
    legend.innerHTML = `
      <div class="decay-legend-item"><div class="decay-legend-dot" style="background:#00e676"></div>Œ∑È´òÔºàÂπ≥Âùá√ó1.5‰ª•‰∏äÔºâ</div>
      <div class="decay-legend-item"><div class="decay-legend-dot" style="background:#00d4ff"></div>Œ∑Âπ≥Âùá‰ªòËøë</div>
      <div class="decay-legend-item"><div class="decay-legend-dot" style="background:#ff3d8e"></div>Œ∑‰ΩéÔºàÂπ≥Âùá√ó0.5‰ª•‰∏ãÔºâ</div>`;
  }

  // Canvas tooltip
  canvas.onmousemove = (e) => {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    let found = null;
    for (const p of points) {
      if (Math.hypot(p.x - mx, p.y - my) < 10) { found = p; break; }
    }
    if (found) {
      const cat = found.category || '?';
      const catInfo = cat !== '?' ? ` / „Ç´„ÉÜ„Ç¥„É™: ${cat}Ôºà${getCategoryName(cat)}Ôºâ` : '';
      showTooltip(e, found.title, `PV: ${found.read_count} / „Çπ„Ç≠: ${found.like_count} / Œ∑: ${(found.eta * 100).toFixed(1)}%${catInfo}`);
    } else {
      hideTooltip();
    }
  };
  canvas.onmouseleave = hideTooltip;
}

// Ranking toggle
document.querySelectorAll('#rankingToggle .toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#rankingToggle .toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    rankingTopN = parseInt(btn.dataset.top);
    renderRanking();
  });
});

// Scatter toggle
document.querySelectorAll('#scatterToggle .toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#scatterToggle .toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    scatterMode = btn.dataset.mode;
    renderScatter();
  });
});

// ===== 3. Category Œ∑ Comparison =====
function renderCategoryChart() {
  const canvas = document.getElementById('categoryCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);

  if (latestSnapshot.length === 0) return;

  // Aggregate by category
  const catStats = {};
  latestSnapshot.forEach(a => {
    const cat = a.category || '?';
    if (cat === '?') return;
    if (!catStats[cat]) catStats[cat] = { totalPV: 0, totalLikes: 0, count: 0 };
    catStats[cat].totalPV += a.read_count;
    catStats[cat].totalLikes += a.like_count;
    catStats[cat].count++;
  });

  const categories = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  const catData = categories.map(c => {
    const s = catStats[c] || { totalPV: 0, totalLikes: 0, count: 0 };
    return {
      cat: c,
      eta: s.totalPV > 0 ? (s.totalLikes / s.totalPV * 100) : 0,
      count: s.count,
      avgPV: s.count > 0 ? Math.round(s.totalPV / s.count) : 0,
    };
  }).filter(d => d.count > 0);

  if (catData.length === 0) return;

  const pad = { top: 20, right: 160, bottom: 20, left: 120 };
  const cw = W - pad.left - pad.right;
  const ch = H - pad.top - pad.bottom;
  const barHeight = Math.min(32, ch / catData.length - 8);
  const gap = (ch - barHeight * catData.length) / Math.max(catData.length - 1, 1);
  const maxEta = Math.max(...catData.map(d => d.eta), 1);

  // Overall avg eta
  const totalLikes = latestSnapshot.reduce((s, a) => s + a.like_count, 0);
  const totalPV = latestSnapshot.reduce((s, a) => s + a.read_count, 0);
  const overallEta = totalPV > 0 ? (totalLikes / totalPV * 100) : 0;

  // A+B background highlight
  const primaryCats = catData.filter(d => CATEGORY_META[d.cat] && CATEGORY_META[d.cat].primary);
  if (primaryCats.length > 0) {
    const firstIdx = catData.indexOf(primaryCats[0]);
    const lastIdx = catData.indexOf(primaryCats[primaryCats.length - 1]);
    const yStart = pad.top + firstIdx * (barHeight + gap) - 4;
    const yEnd = pad.top + lastIdx * (barHeight + gap) + barHeight + 4;
    ctx.fillStyle = '#00d4ff08';
    ctx.fillRect(pad.left, yStart, cw, yEnd - yStart);
    ctx.fillStyle = '#00d4ff30';
    ctx.font = '10px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText('‰∏ÄÊ¨°ÊÉÖÂ†±„Çæ„Éº„É≥', pad.left + 4, yStart + 10);
  }

  // Overall avg eta vertical line
  const avgX = pad.left + (overallEta / maxEta) * cw;
  ctx.strokeStyle = '#ffb02044';
  ctx.lineWidth = 1;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(avgX, pad.top);
  ctx.lineTo(avgX, pad.top + ch);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ffb02077';
  ctx.font = '10px JetBrains Mono';
  ctx.textAlign = 'center';
  ctx.fillText(`ÂÖ®‰ΩìŒ∑=${overallEta.toFixed(1)}%`, avgX, pad.top - 6);

  // Draw bars
  const barPoints = [];
  catData.forEach((d, i) => {
    const y = pad.top + i * (barHeight + gap);
    const barW = (d.eta / maxEta) * cw;
    const color = getCategoryColor(d.cat);
    const meta = CATEGORY_META[d.cat];
    const opacity = d.cat === 'F' ? '66' : 'cc';

    // Bar
    ctx.fillStyle = color + opacity;
    ctx.fillRect(pad.left, y, barW, barHeight);

    // Label left
    ctx.fillStyle = color;
    ctx.font = '13px JetBrains Mono';
    ctx.textAlign = 'right';
    ctx.fillText(`[${d.cat}] ${meta ? meta.name : '?'}`, pad.left - 8, y + barHeight / 2 + 5);

    // Stats right
    ctx.fillStyle = '#8888a0';
    ctx.font = '12px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText(`${d.eta.toFixed(1)}%  (${d.count}Ë®ò‰∫ã / avg ${d.avgPV} PV)`, pad.left + barW + 8, y + barHeight / 2 + 5);

    barPoints.push({ x: pad.left, y, w: barW, h: barHeight, ...d });
  });

  document.getElementById('catBadge').textContent = `${catData.length} categories`;

  // Legend
  document.getElementById('categoryLegend').innerHTML = `
    <div class="decay-legend-item" style="color:#00d4ff55">‚ñ† ‰∏ÄÊ¨°ÊÉÖÂ†±„Çæ„Éº„É≥ÔºàA+BÔºâ</div>
    <div class="decay-legend-item" style="color:#ffb02077">--- ÂÖ®‰ΩìÂπ≥Âùá Œ∑=${overallEta.toFixed(1)}%</div>`;

  // Tooltip
  canvas.onmousemove = (e) => {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    let found = null;
    for (const b of barPoints) {
      if (mx >= b.x && mx <= b.x + b.w + 160 && my >= b.y && my <= b.y + b.h) { found = b; break; }
    }
    if (found) {
      showTooltip(e, `„Ç´„ÉÜ„Ç¥„É™${found.cat}: ${getCategoryName(found.cat)}`,
        `Âπ≥ÂùáŒ∑: ${found.eta.toFixed(1)}% / Ë®ò‰∫ãÊï∞: ${found.count} / Âπ≥ÂùáPV: ${found.avgPV}`);
    } else {
      hideTooltip();
    }
  };
  canvas.onmouseleave = hideTooltip;
}

// ===== 4. Recent Articles Œ∑ Dot Plot =====
function renderEtaTrend() {
  const canvas = document.getElementById('etaTrendCanvas');
  const ctx = canvas.getContext('2d');
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);

  const dates = [...new Set(articlesData.map(a => a.date))].sort();
  const latestDate = dates[dates.length - 1];

  // Build 14-day range ending at latestDate
  const endDate = new Date(latestDate + 'T00:00:00');
  const daySlots = [];
  for (let i = 13; i >= 0; i--) {
    const d = new Date(endDate);
    d.setDate(d.getDate() - i);
    const iso = d.toISOString().substring(0, 10);
    daySlots.push(iso);
  }

  // Find articles published within this 14-day range, using latest snapshot eta
  const recentArticles = latestSnapshot
    .filter(a => {
      if (!a.published_at) return false;
      const pubDay = a.published_at.substring(0, 10);
      return pubDay >= daySlots[0] && pubDay <= daySlots[daySlots.length - 1];
    })
    .map(a => ({
      ...a,
      pubDay: a.published_at.substring(0, 10),
      eta: a.read_count > 0 ? (a.like_count / a.read_count * 100) : 0,
    }));

  if (recentArticles.length === 0) {
    ctx.fillStyle = '#555570';
    ctx.font = '15px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('Áõ¥Ëøë2ÈÄ±Èñì„Å´ÊäïÁ®ø„Åï„Çå„ÅüË®ò‰∫ã„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', W / 2, H / 2);
    document.getElementById('etaTrendLegend').innerHTML = '';
    document.getElementById('etaTrendBadge').textContent = '0 articles';
    return;
  }

  const pad = { top: 28, right: 40, bottom: 58, left: 55 };
  const cw = W - pad.left - pad.right;
  const ch = H - pad.top - pad.bottom;

  // Y scale
  const maxEta = Math.ceil(Math.max(...recentArticles.map(a => a.eta), 10) / 5) * 5;

  // Grid
  const gridSteps = 5;
  for (let i = 0; i <= gridSteps; i++) {
    const y = pad.top + (ch / gridSteps) * i;
    ctx.strokeStyle = '#1e1e2e';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();

    const val = (maxEta / gridSteps * (gridSteps - i)).toFixed(0);
    ctx.fillStyle = '#555570';
    ctx.font = '11px JetBrains Mono';
    ctx.textAlign = 'right';
    ctx.fillText(val + '%', pad.left - 8, y + 3);
  }

  // Average Œ∑ line
  const avgEta = latestSnapshot.reduce((s, a) => s + a.like_count, 0) /
                 Math.max(latestSnapshot.reduce((s, a) => s + a.read_count, 0), 1) * 100;
  const avgY = pad.top + ch - (avgEta / maxEta) * ch;
  ctx.strokeStyle = '#ffb02044';
  ctx.lineWidth = 1;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(pad.left, avgY);
  ctx.lineTo(W - pad.right, avgY);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ffb02077';
  ctx.font = '11px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillText(`ÂÖ®‰ΩìÂπ≥Âùá Œ∑=${avgEta.toFixed(1)}%`, pad.left + 4, avgY - 6);

  // X axis - 14 day slots
  const slotWidth = cw / daySlots.length;

  // Vertical slot separators (subtle)
  daySlots.forEach((d, i) => {
    const x = pad.left + slotWidth * i + slotWidth / 2;
    ctx.strokeStyle = '#1a1a28';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, pad.top + ch); ctx.stroke();
  });

  // X labels
  const dowLabels = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
  ctx.font = '11px JetBrains Mono';
  ctx.textAlign = 'center';
  daySlots.forEach((d, i) => {
    const x = pad.left + slotWidth * i + slotWidth / 2;
    const label = d.substring(5); // MM-DD
    const dayOfWeek = new Date(d + 'T00:00:00').getDay();
    const dowLabel = `(${dowLabels[dayOfWeek]})`;
    if (dayOfWeek === 0 || dayOfWeek === 6) {
      ctx.fillStyle = '#666680';
    } else {
      ctx.fillStyle = '#444460';
    }
    ctx.fillText(label, x, H - pad.bottom + 16);
    ctx.fillText(dowLabel, x, H - pad.bottom + 30);
  });

  // Average Œ∑ for color thresholds
  const avgEtaForColor = latestSnapshot.reduce((s, a) => s + a.like_count, 0) /
                 Math.max(latestSnapshot.reduce((s, a) => s + a.read_count, 0), 1) * 100;

  // Plot dots
  const plotPoints = [];
  // Group articles by pubDay to handle same-day offsets
  const byDay = {};
  recentArticles.forEach(a => {
    if (!byDay[a.pubDay]) byDay[a.pubDay] = [];
    byDay[a.pubDay].push(a);
  });

  Object.entries(byDay).forEach(([day, articles]) => {
    const slotIdx = daySlots.indexOf(day);
    if (slotIdx === -1) return;
    const cx = pad.left + slotWidth * slotIdx + slotWidth / 2;

    articles.forEach((a, j) => {
      const cy = pad.top + ch - (a.eta / maxEta) * ch;
      // Offset horizontally if multiple on same day
      const offset = articles.length > 1 ? (j - (articles.length - 1) / 2) * 14 : 0;
      const px = cx + offset;

      // Color by category
      const cat = a.category || '?';
      const color = cat !== '?' ? getCategoryColor(cat) : '#00d4ff';

      // Glow
      ctx.beginPath();
      ctx.arc(px, cy, 10, 0, Math.PI * 2);
      ctx.fillStyle = color + '15';
      ctx.fill();

      // Dot
      ctx.beginPath();
      ctx.arc(px, cy, 6, 0, Math.PI * 2);
      ctx.fillStyle = color + 'cc';
      ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Category label above Œ∑
      if (cat !== '?') {
        ctx.fillStyle = color + '99';
        ctx.font = '9px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText(`[${cat}]`, px, cy - 22);
      }

      // Œ∑ label above dot
      ctx.fillStyle = color;
      ctx.font = '12px JetBrains Mono';
      ctx.textAlign = 'center';
      ctx.fillText(a.eta.toFixed(1) + '%', px, cy - 12);

      plotPoints.push({ x: px, y: cy, color, ...a });
    });
  });

  document.getElementById('etaTrendBadge').textContent = `${recentArticles.length} articles`;

  // Legend - category colors
  const legend = document.getElementById('etaTrendLegend');
  legend.innerHTML = Object.entries(CATEGORY_META).map(([k, v]) =>
    `<div class="decay-legend-item"><div class="decay-legend-dot" style="background:${v.color}"></div>${k} ${v.name}</div>`
  ).join('') + `<div class="decay-legend-item" style="margin-left:12px;color:#ffb02077">--- ÂÖ®‰ΩìÂπ≥Âùá Œ∑=${avgEtaForColor.toFixed(1)}%</div>`;

  // Tooltip
  canvas.onmousemove = (e) => {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    let found = null;
    for (const p of plotPoints) {
      if (Math.hypot(p.x - mx, p.y - my) < 12) { found = p; break; }
    }
    if (found) {
      showTooltip(e, found.title, `ÊäïÁ®ø: ${found.pubDay} / PV: ${found.read_count} / „Çπ„Ç≠: ${found.like_count} / Œ∑: ${found.eta.toFixed(1)}%`);
    } else {
      hideTooltip();
    }
  };
  canvas.onmouseleave = hideTooltip;
}

// ===== 4. Article Daily Trend (sparkline rows) =====
let trendDeltaCache = null;
let trendActiveMetric = 'pv_delta';

function computeDailyDeltas() {
  const byId = {};
  articlesData.forEach(a => {
    if (!byId[a.note_id]) byId[a.note_id] = [];
    byId[a.note_id].push(a);
  });

  const allDates = [...new Set(articlesData.map(a => a.date))].sort();
  if (allDates.length < 2) return { dates: [], series: [] };

  const deltaDates = allDates.slice(1);
  const series = [];
  Object.entries(byId).forEach(([noteId, rows]) => {
    rows.sort((a, b) => a.date.localeCompare(b.date));
    const deltas = [];
    let totalPvDelta = 0, totalLikeDelta = 0;
    for (let i = 1; i < rows.length; i++) {
      const pvDelta = Math.max(0, rows[i].read_count - rows[i - 1].read_count);
      const likeDelta = Math.max(0, rows[i].like_count - rows[i - 1].like_count);
      deltas.push({ date: rows[i].date, pv_delta: pvDelta, like_delta: likeDelta });
      totalPvDelta += pvDelta;
      totalLikeDelta += likeDelta;
    }
    if (deltas.length > 0) {
      series.push({
        note_id: noteId, key: rows[0].key, title: rows[0].title,
        published_at: rows[0].published_at || '',
        category: rows[0].category || '?',
        totalPvDelta, totalLikeDelta, deltas,
      });
    }
  });
  return { dates: deltaDates, series };
}

function filterTrendSeries(allData, metric) {
  const dayFilter = parseInt(document.getElementById('trendDayFilter').value) || 0;
  const minDelta = parseInt(document.getElementById('trendMinDelta').value) || 0;
  let filtered = allData.series;

  if (dayFilter > 0 && allData.dates.length > 0) {
    const latestDate = allData.dates[allData.dates.length - 1];
    const cutoff = new Date(latestDate + 'T00:00:00');
    cutoff.setDate(cutoff.getDate() - dayFilter);
    const cutoffStr = cutoff.toISOString().substring(0, 10);
    filtered = filtered.filter(s => s.published_at && s.published_at.substring(0, 10) >= cutoffStr);
  }

  if (minDelta > 0) {
    const totalKey = metric === 'pv_delta' ? 'totalPvDelta' : 'totalLikeDelta';
    filtered = filtered.filter(s => s[totalKey] >= minDelta);
  }

  const catFilter = document.getElementById('trendCatFilter').value;
  if (catFilter) {
    const cats = catFilter.split('');
    filtered = filtered.filter(s => cats.includes(s.category));
  }

  filtered.sort((a, b) => (b.published_at || '').localeCompare(a.published_at || ''));
  return filtered;
}

function drawSparkline(canvas, deltas, dates, metric, color, pubDate) {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.clientWidth;
  const H = canvas.clientHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, W, H);

  if (deltas.length === 0) return;

  const padX = 4;
  const padTop = 14;
  const padBottom = 16; // space for date labels
  const cw = W - padX * 2;
  const ch = H - padTop - padBottom;

  const vals = dates.map(d => {
    const found = deltas.find(dd => dd.date === d);
    return found ? found[metric] : 0;
  });
  const maxVal = Math.max(...vals, 1);

  const xPos = (i) => padX + (cw / Math.max(vals.length - 1, 1)) * i;
  const yPos = (v) => padTop + ch - (v / maxVal) * ch;

  // Fill area
  ctx.beginPath();
  ctx.moveTo(padX, padTop + ch);
  vals.forEach((v, i) => ctx.lineTo(xPos(i), yPos(v)));
  ctx.lineTo(padX + cw, padTop + ch);
  ctx.closePath();
  ctx.fillStyle = color + '18';
  ctx.fill();

  // Line
  ctx.beginPath();
  vals.forEach((v, i) => {
    if (i === 0) ctx.moveTo(xPos(i), yPos(v));
    else ctx.lineTo(xPos(i), yPos(v));
  });
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Dots
  vals.forEach((v, i) => {
    ctx.beginPath();
    ctx.arc(xPos(i), yPos(v), 2.5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  });

  // Publish date marker
  if (pubDate) {
    // Find nearest date in dates array (delta dates start from day after first data)
    const pubIdx = dates.indexOf(pubDate);
    // Also check if pubDate is one day before the first delta date
    if (pubIdx >= 0) {
      const px = xPos(pubIdx);
      ctx.strokeStyle = color + '66';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(px, padTop);
      ctx.lineTo(px, padTop + ch);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = color + 'aa';
      ctx.font = '9px JetBrains Mono';
      ctx.textAlign = 'center';
      ctx.fillText('pub', px, padTop - 2);
    }
  }

  // X-axis date labels (first and last only)
  ctx.fillStyle = '#888888';
  ctx.font = '11px JetBrains Mono';
  const fmt = (d) => d.substring(5).replace('-', '/');
  // First date
  ctx.textAlign = 'start';
  ctx.fillText(fmt(dates[0]), padX, H - 2);
  // Last date
  if (dates.length > 1) {
    ctx.textAlign = 'end';
    ctx.fillText(fmt(dates[dates.length - 1]), padX + cw, H - 2);
  }
}

function renderTrendRows() {
  if (!trendDeltaCache || trendDeltaCache.dates.length === 0) {
    document.getElementById('trendRows').innerHTML = '<div class="no-data">Â∑ÆÂàÜ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºà2Êó•‰ª•‰∏ä„ÅÆ„Éá„Éº„Çø„ÅåÂøÖË¶ÅÔºâ</div>';
    document.getElementById('trendBadge').textContent = '0 articles';
    return;
  }

  const metric = trendActiveMetric;
  const filtered = filterTrendSeries(trendDeltaCache, metric);
  const dates = trendDeltaCache.dates;
  const container = document.getElementById('trendRows');
  const totalKey = metric === 'pv_delta' ? 'totalPvDelta' : 'totalLikeDelta';
  const label = metric === 'pv_delta' ? 'PV' : '„Çπ„Ç≠';

  if (filtered.length === 0) {
    container.innerHTML = '<div class="no-data">Êù°‰ª∂„Å´‰∏ÄËá¥„Åô„ÇãË®ò‰∫ã„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
    document.getElementById('trendBadge').textContent = '0 articles';
    return;
  }

  document.getElementById('trendBadge').textContent = `${filtered.length} articles`;

  container.innerHTML = filtered.map((s, i) => {
    const shortTitle = s.title.replace(/^„Äê.*?„Äë/, '').replace(/\|.*$/, '').trim();
    const displayTitle = shortTitle;
    const total = s[totalKey];
    const cat = s.category || '?';
    const catColor = getCategoryColor(cat);
    const catInfo = cat !== '?' ? ` / „Ç´„ÉÜ„Ç¥„É™: ${cat}Ôºà${getCategoryName(cat)}Ôºâ` : '';
    return `
      <div class="trend-row" data-idx="${i}"
        onmouseenter="showTooltip(event, '${escHtml(s.title)}', '${label}Â¢óÂàÜÂêàË®à: +${total} / ÊäïÁ®ø: ${s.published_at ? s.published_at.substring(0,10) : "‰∏çÊòé"}${catInfo}')"
        onmouseleave="hideTooltip()">
        <div class="trend-row-title"><span class="cat-badge" style="color:${catColor}">[${cat}]</span>${escHtml(displayTitle)}<div style="font-size:10px;color:var(--text-muted);margin-top:2px;">${s.published_at ? s.published_at.substring(0,10) : ''}</div></div>
        <canvas class="trend-row-spark" data-series-idx="${i}"></canvas>
        <div class="trend-row-value" style="color:${catColor}">+${total}</div>
      </div>`;
  }).join('');

  // Draw sparklines after DOM update
  requestAnimationFrame(() => {
    container.querySelectorAll('.trend-row-spark').forEach(canvas => {
      const idx = parseInt(canvas.dataset.seriesIdx);
      const s = filtered[idx];
      if (!s) return;
      const color = getCategoryColor(s.category || '?');
      const pubDate = s.published_at ? s.published_at.substring(0, 10) : null;
      drawSparkline(canvas, s.deltas, dates, metric, color, pubDate);
    });
  });
}

function renderTrendCharts() {
  trendDeltaCache = computeDailyDeltas();
  renderTrendRows();
}

// Tab switching
document.querySelectorAll('.trend-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.trend-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    trendActiveMetric = tab.dataset.metric;
    renderTrendRows();
  });
});

// Filter event listeners
['trendDayFilter', 'trendMinDelta', 'trendCatFilter'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    renderTrendRows();
  });
});

// ===== Tooltip =====
function showTooltip(e, title, body) {
  const tt = document.getElementById('tooltip');
  document.getElementById('tooltipTitle').textContent = title;
  document.getElementById('tooltipBody').textContent = body;
  tt.style.display = 'block';
  const ttWidth = tt.offsetWidth;
  const spaceRight = window.innerWidth - e.clientX;
  if (spaceRight < ttWidth + 24) {
    tt.style.left = (e.clientX - ttWidth - 14) + 'px';
  } else {
    tt.style.left = (e.clientX + 14) + 'px';
  }
  tt.style.top = (e.clientY - 10) + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

function escHtml(s) {
  return s.replace(/'/g, "\\'").replace(/"/g, '&quot;');
}

// ===== Load from repo (GitHub Pages) =====
async function loadFromRepo() {
  try {
    // Load articles.csv
    const res = await fetch('./data/articles.csv');
    if (res.ok) {
      const text = await res.text();
      const rows = parseCSV(text);
      if (rows.length > 0) {
        // Load article_categories.csv
        try {
          const catRes = await fetch('./data/article_categories.csv');
          if (catRes.ok) {
            const catText = await catRes.text();
            const catRows = parseCSV(catText);
            categoryMap = {};
            catRows.forEach(r => { categoryMap[r.key] = r.category; });
          }
        } catch (e) {}

        // Load daily_summary.csv
        try {
          const sumRes = await fetch('./data/daily_summary.csv');
          if (sumRes.ok) {
            const sumText = await sumRes.text();
            const sumRows = parseCSV(sumText);
            summaryData = sumRows.map(r => ({
              date: r.date,
              articleCount: parseInt(r.article_count) || 0,
              totalPV: parseInt(r.total_pv) || 0,
              totalLikes: parseInt(r.total_like) || 0,
              totalComments: parseInt(r.total_comment) || 0,
              followerCount: parseInt(r.follower_count) || 0,
            })).sort((a, b) => a.date.localeCompare(b.date));
          }
        } catch (e) {}

        processData(rows);
        return true;
      }
    }
  } catch (e) {}
  return false;
}

// ===== Init =====
window.addEventListener('resize', () => {
  if (latestSnapshot.length > 0) {
    renderScatter();
    renderCategoryChart();
    renderEtaTrend();
    renderTrendCharts();
  }
});

// Try to load from repo on init
loadFromRepo();
</script>
</body>
</html>
